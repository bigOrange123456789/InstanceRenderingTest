<!DOCTYPE html>
<html lang="en">
<head>
	<title>three.js webgl - interactive instances (gpu)</title>
	<meta charset="utf-8">
	<style>
		body {overflow:hidden;}
	</style>
</head>
<body>
	<div id="container"></div>
	<script id="vertInstanced" type="x-shader/x-vertex">
	//vertex顶点着色器
	    //#define是宏定义
	    //const必须在声明的时候初始化
	    //attribute属性变量、uniform一致变量、varying易变变量 声明时一定不能初始化
		//attribute只能用于顶点着色器vertex，不能用于片元着色器fragment
		//          存储顶点的各种属性
		//
		#define SHADER_NAME vertInstanced

		precision highp float;

		uniform mat4 modelViewMatrix;//mat表示这是一个矩阵
		uniform mat4 projectionMatrix;

		attribute vec3 position;//vec3指有3个浮点数元素的矢量（vector）
		attribute vec3 mcol0;
		attribute vec3 mcol1;
		attribute vec3 mcol2;
		attribute vec3 mcol3;

		#ifdef PICKING
			attribute vec3 pickingColor;//如果拾取定义拾取颜色
		#else
			attribute vec3 color;      //如果没有拾取，定义普通颜色
			varying vec3 vPosition;
		#endif

		varying vec3 vColor;

		void main()	{
			mat4 matrix = mat4(
				vec4( mcol0, 0 ),
				vec4( mcol1, 0 ),
				vec4( mcol2, 0 ),
				vec4( mcol3, 1 )
			);
			vec3 positionEye = ( modelViewMatrix * matrix * vec4( position, 1.0 ) ).xyz;
			#ifdef PICKING
				vColor = pickingColor;
			#else
				vColor = color;
				vPosition = positionEye;
			#endif
			gl_Position = projectionMatrix * vec4( positionEye, 1.0 );
		}
	</script>
	<script id="fragInstanced" type="x-shader/x-fragment">
		#define SHADER_NAME fragInstanced

		#extension GL_OES_standard_derivatives : enable

		precision highp float;

		varying vec3 vColor;

		#ifndef PICKING
			varying vec3 vPosition;
		#endif

		void main()	{

			#ifdef PICKING
				gl_FragColor = vec4( vColor, 1.0 );
			#else
				vec3 fdx = dFdx( vPosition );
				vec3 fdy = dFdy( vPosition );
				vec3 normal = normalize( cross( fdx, fdy ) );
				float diffuse = dot( normal, vec3( 0.0, 0.0, 1.0 ) );

				gl_FragColor = vec4( diffuse * vColor, 1.0 );
			#endif

		}

	</script>
	<script src="three.js"></script>
	<script src="OrbitControls.js"></script>
	<script type="module">
		import * as THREE from './three.module.js';
		var container;
		var camera,scene, renderer;
		var singleMaterial;
		var materialList = [];
		var geometryList = [];
		var objectCount = 0;
		var geometrySize = new THREE.Vector3();
		var mouse = new THREE.Vector2();
		var scale = 1.03;

		var loader = new THREE.BufferGeometryLoader();

		// gui
		var instanceCount=1;

		init();
		initMesh();

		function clean() {
			THREE.Cache.clear();
			materialList.forEach( function ( m ) {
				m.dispose();
			} );
			geometryList.forEach( function ( g ) {
				g.dispose();
			} );
			scene = new THREE.Scene();
			scene.background = new THREE.Color( 0xffffff );

			scene.add( camera );


			materialList = [];
			geometryList = [];
			objectCount = 0;

			singleMaterial = undefined;

		}

		var randomizeMatrix = function () {
			var position = new THREE.Vector3();
			var rotation = new THREE.Euler();
			var quaternion = new THREE.Quaternion();
			var scale = new THREE.Vector3();

			return function ( matrix ) {
				position.x = Math.random() * 40 - 20;
				position.y = Math.random() * 40 - 20;
				position.z = Math.random() * 40 - 20;

				rotation.x = Math.random() * 2 * Math.PI;
				rotation.y = Math.random() * 2 * Math.PI;
				rotation.z = Math.random() * 2 * Math.PI;

				quaternion.setFromEuler( rotation );
				scale.x = scale.y = scale.z = Math.random() * 1;
				matrix.compose( position, quaternion, scale );
			};
		}();

		function initMesh() {
			clean();
			// make instances
			loader.load( './suzanne_buffergeometry.json', function ( geo ) {
				geo = geo.toNonIndexed();
				geo.computeBoundingBox();
				geo.boundingBox.getSize( geometrySize );
				geometryList.push( geo );
				makeInstanced( geo );
				render();
			} );
		}

		function makeInstanced( geo ) {
			// material
			//顶点着色器
			var vert = document.getElementById( 'vertInstanced' ).textContent;//代码的文字内容
			//片元着色器
			var frag = document.getElementById( 'fragInstanced' ).textContent;//代码的文字内容//console.log(vert);//console.log(frag);

			//材质
			var material = new THREE.RawShaderMaterial( {
				//通过顶点着色器和片元着色器生成材质
				vertexShader: vert,
				fragmentShader: frag,
			} );
			materialList.push( material );//材质放入材质列表

			var igeo = new THREE.InstancedBufferGeometry();
			geometryList.push( igeo );

			//克隆几何的点集合
			var vertices = geo.attributes.position.clone();
			igeo.setAttribute( 'position', vertices );

			//
			var mcol0 = new THREE.InstancedBufferAttribute(
				new Float32Array( instanceCount * 3 ), 3
			);//console.log(mcol0);
			var mcol1 = new THREE.InstancedBufferAttribute(
				new Float32Array( instanceCount * 3 ), 3
			);
			var mcol2 = new THREE.InstancedBufferAttribute(
				new Float32Array( instanceCount * 3 ), 3
			);
			var mcol3 = new THREE.InstancedBufferAttribute(
				new Float32Array( instanceCount * 3 ), 3
			);
			var matrix = new THREE.Matrix4();//4维方阵
			var me = matrix.elements;
			for ( var i = 0, ul = mcol0.count; i < ul; i ++ ) {
				randomizeMatrix( matrix );
				var object = new THREE.Object3D();
				objectCount ++;
				object.applyMatrix( matrix );
				mcol0.setXYZ( i, me[ 0 ], me[ 1 ], me[ 2 ] );
				mcol1.setXYZ( i, me[ 4 ], me[ 5 ], me[ 6 ] );
				mcol2.setXYZ( i, me[ 8 ], me[ 9 ], me[ 10 ] );
				mcol3.setXYZ( i, me[ 12 ], me[ 13 ], me[ 14 ] );
			}
			// igeo.setAttribute( 'matrix', matrices );
			igeo.setAttribute( 'mcol0', mcol0 );//几何有4个属性//mcol0
			igeo.setAttribute( 'mcol1', mcol1 );
			igeo.setAttribute( 'mcol2', mcol2 );
			igeo.setAttribute( 'mcol3', mcol3 );

			//生成一个随机颜色
			var randCol = function () {
				return Math.random();
			};
			var colors = new THREE.InstancedBufferAttribute(
				new Float32Array( instanceCount * 3 ), 3
			);
			for ( var i = 0, ul = colors.count; i < ul; i ++ ) {
				colors.setXYZ( i, randCol(), randCol(), randCol() );
			}
			igeo.setAttribute( 'color', colors );

			// mesh
			var mesh = new THREE.Mesh( igeo, material );
			mesh.scale.set(100,100,100);
			scene.add( mesh );

		}

		function init() {
			// camera
			camera = new THREE.PerspectiveCamera(
				70, window.innerWidth / window.innerHeight, 0.001, 10000
			);//fov摄像机视锥体垂直视野角度//aspect摄像机视锥体长宽比//near摄像机视锥体近端面//far摄像机视锥体远端面
			camera.position.z = 40;
			var targetPosition = new THREE.Vector3(0, 0, 0);
			camera.lookAt(targetPosition);

			// renderer
			container = document.getElementById( "container" );
			renderer = new THREE.WebGLRenderer( {
				antialias: true,
				alpha: true
			} );
			if ( renderer.extensions.get( 'ANGLE_instanced_arrays' ) === null ) {
				return;
			}
			renderer.setPixelRatio( window.devicePixelRatio );
			renderer.setSize( window.innerWidth, window.innerHeight );

			new OrbitControls(camera , renderer.domElement,THREE);

			//renderer.sortObjects = false;
			container.appendChild( renderer.domElement );

			if ( renderer.extensions.get( 'ANGLE_instanced_arrays' ) === null ) {
				throw 'ANGLE_instanced_arrays not supported';
			}
		}
		function render() {
			renderer.render( scene, camera );
			requestAnimationFrame(render);
		}
	</script>

</body>
</html>
