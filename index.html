<!DOCTYPE html>
<html lang="en">
<head>
	<title>three.js webgl - interactive instances (gpu)</title>
	<meta charset="utf-8">
	<style>
		body {overflow:hidden;}
	</style>
</head>
<body>
	<div id="container"></div>
	<script id="vertInstanced" type="x-shader/x-vertex">
		#define SHADER_NAME vertInstanced

		precision highp float;

		uniform mat4 modelViewMatrix;
		uniform mat4 projectionMatrix;

		attribute vec3 position;
		attribute vec3 mcol0;
		attribute vec3 mcol1;
		attribute vec3 mcol2;
		attribute vec3 mcol3;

		#ifdef PICKING
			attribute vec3 pickingColor;
		#else
			attribute vec3 color;
			varying vec3 vPosition;
		#endif

		varying vec3 vColor;

		void main()	{

			mat4 matrix = mat4(
				vec4( mcol0, 0 ),
				vec4( mcol1, 0 ),
				vec4( mcol2, 0 ),
				vec4( mcol3, 1 )
			);

			vec3 positionEye = ( modelViewMatrix * matrix * vec4( position, 1.0 ) ).xyz;

			#ifdef PICKING
				vColor = pickingColor;
			#else
				vColor = color;
				vPosition = positionEye;
			#endif

			gl_Position = projectionMatrix * vec4( positionEye, 1.0 );

		}

	</script>
	<script id="fragInstanced" type="x-shader/x-fragment">
		#define SHADER_NAME fragInstanced

		#extension GL_OES_standard_derivatives : enable

		precision highp float;

		varying vec3 vColor;

		#ifndef PICKING
			varying vec3 vPosition;
		#endif

		void main()	{

			#ifdef PICKING
				gl_FragColor = vec4( vColor, 1.0 );
			#else
				vec3 fdx = dFdx( vPosition );
				vec3 fdy = dFdy( vPosition );
				vec3 normal = normalize( cross( fdx, fdy ) );
				float diffuse = dot( normal, vec3( 0.0, 0.0, 1.0 ) );

				gl_FragColor = vec4( diffuse * vColor, 1.0 );
			#endif

		}

	</script>
	<script src="three.js"></script>
	<script src="OrbitControls.js"></script>
	<script type="module">
		import * as THREE from './three.module.js';
		var container;
		var camera,scene, renderer;
		var pickingData, pickingScene;
		var singleMaterial, singlePickingMaterial;
		var materialList = [];
		var geometryList = [];
		var objectCount = 0;
		var geometrySize = new THREE.Vector3();
		var mouse = new THREE.Vector2();
		var scale = 1.03;

		var loader = new THREE.BufferGeometryLoader();

		// gui
		var instanceCount=100;

		init();
		initMesh();

		function clean() {
			THREE.Cache.clear();
			materialList.forEach( function ( m ) {
				m.dispose();
			} );
			geometryList.forEach( function ( g ) {
				g.dispose();
			} );
			scene = new THREE.Scene();
			scene.background = new THREE.Color( 0xffffff );

			scene.add( camera );

			pickingScene = new THREE.Scene();
			pickingData = {};
			materialList = [];
			geometryList = [];
			objectCount = 0;

			singleMaterial = undefined;
			singlePickingMaterial = undefined;

		}

		var randomizeMatrix = function () {
			var position = new THREE.Vector3();
			var rotation = new THREE.Euler();
			var quaternion = new THREE.Quaternion();
			var scale = new THREE.Vector3();

			return function ( matrix ) {
				position.x = Math.random() * 40 - 20;
				position.y = Math.random() * 40 - 20;
				position.z = Math.random() * 40 - 20;

				rotation.x = Math.random() * 2 * Math.PI;
				rotation.y = Math.random() * 2 * Math.PI;
				rotation.z = Math.random() * 2 * Math.PI;

				quaternion.setFromEuler( rotation );
				scale.x = scale.y = scale.z = Math.random() * 1;
				matrix.compose( position, quaternion, scale );
			};
		}();

		function initMesh() {
			clean();
			// make instances
			loader.load( './suzanne_buffergeometry.json', function ( geo ) {
				geo = geo.toNonIndexed();
				geo.computeBoundingBox();
				geo.boundingBox.getSize( geometrySize );
				geometryList.push( geo );
				makeInstanced( geo );
				render();
			} );
		}

		function makeInstanced( geo ) {
			// material
			var vert = document.getElementById( 'vertInstanced' ).textContent;
			var frag = document.getElementById( 'fragInstanced' ).textContent;

			var material = new THREE.RawShaderMaterial( {
				vertexShader: vert,
				fragmentShader: frag,
			} );
			materialList.push( material );

			var pickingMaterial = new THREE.RawShaderMaterial( {
				vertexShader: "#define PICKING\n" + vert,
				fragmentShader: "#define PICKING\n" + frag
			} );
			materialList.push( pickingMaterial );

			// geometry
			var igeo = new THREE.InstancedBufferGeometry();
			geometryList.push( igeo );

			var vertices = geo.attributes.position.clone();
			igeo.setAttribute( 'position', vertices );

			var mcol0 = new THREE.InstancedBufferAttribute(
				new Float32Array( instanceCount * 3 ), 3
			);
			var mcol1 = new THREE.InstancedBufferAttribute(
				new Float32Array( instanceCount * 3 ), 3
			);
			var mcol2 = new THREE.InstancedBufferAttribute(
				new Float32Array( instanceCount * 3 ), 3
			);
			var mcol3 = new THREE.InstancedBufferAttribute(
				new Float32Array( instanceCount * 3 ), 3
			);
			var matrix = new THREE.Matrix4();
			var me = matrix.elements;
			for ( var i = 0, ul = mcol0.count; i < ul; i ++ ) {
				randomizeMatrix( matrix );
				var object = new THREE.Object3D();
				objectCount ++;
				object.applyMatrix( matrix );
				pickingData[ i + 1 ] = object;
				// matrices.set( matrix.elements, i * 16 );
				mcol0.setXYZ( i, me[ 0 ], me[ 1 ], me[ 2 ] );
				mcol1.setXYZ( i, me[ 4 ], me[ 5 ], me[ 6 ] );
				mcol2.setXYZ( i, me[ 8 ], me[ 9 ], me[ 10 ] );
				mcol3.setXYZ( i, me[ 12 ], me[ 13 ], me[ 14 ] );
			}
			// igeo.setAttribute( 'matrix', matrices );
			igeo.setAttribute( 'mcol0', mcol0 );
			igeo.setAttribute( 'mcol1', mcol1 );
			igeo.setAttribute( 'mcol2', mcol2 );
			igeo.setAttribute( 'mcol3', mcol3 );

			var randCol = function () {
				return Math.random();
			};
			var colors = new THREE.InstancedBufferAttribute(
				new Float32Array( instanceCount * 3 ), 3
			);
			for ( var i = 0, ul = colors.count; i < ul; i ++ ) {
				colors.setXYZ( i, randCol(), randCol(), randCol() );
			}
			igeo.setAttribute( 'color', colors );

			var col = new THREE.Color();
			var pickingColors = new THREE.InstancedBufferAttribute(
				new Float32Array( instanceCount * 3 ), 3
			);
			for ( var i = 0, ul = pickingColors.count; i < ul; i ++ ) {
				col.setHex( i + 1 );
				pickingColors.setXYZ( i, col.r, col.g, col.b );
			}
			igeo.setAttribute( 'pickingColor', pickingColors );

			// mesh

			var mesh = new THREE.Mesh( igeo, material );
			scene.add( mesh );

			var pickingMesh = new THREE.Mesh( igeo, pickingMaterial );
			pickingScene.add( pickingMesh );

		}

		function init() {
			// camera
			camera = new THREE.PerspectiveCamera(
				70, window.innerWidth / window.innerHeight, 0.001, 10000
			);//fov摄像机视锥体垂直视野角度//aspect摄像机视锥体长宽比//near摄像机视锥体近端面//far摄像机视锥体远端面
			camera.position.z = 40;
			var targetPosition = new THREE.Vector3(0, 0, 0);
			camera.lookAt(targetPosition);

			// renderer
			container = document.getElementById( "container" );
			renderer = new THREE.WebGLRenderer( {
				antialias: true,
				alpha: true
			} );
			if ( renderer.extensions.get( 'ANGLE_instanced_arrays' ) === null ) {
				//document.getElementById( "notSupported" ).style.display = "";
				return;
			}
			renderer.setPixelRatio( window.devicePixelRatio );
			renderer.setSize( window.innerWidth, window.innerHeight );

			new OrbitControls(camera , renderer.domElement,THREE);

			//renderer.sortObjects = false;
			container.appendChild( renderer.domElement );

			if ( renderer.extensions.get( 'ANGLE_instanced_arrays' ) === null ) {
				throw 'ANGLE_instanced_arrays not supported';
			}
		}
		function render() {
			renderer.render( scene, camera );
			requestAnimationFrame(render);
		}
	</script>

</body>
</html>
