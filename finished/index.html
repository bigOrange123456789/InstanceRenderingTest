<!DOCTYPE html>
<html lang="en">
<head>
    <title>同屏显示1089人</title>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
</head>
<body>
<div id="container"></div>

<script id="vertexShader" type="x-shader/x-vertex">
		precision highp float;
		uniform mat4 modelViewMatrix;
		uniform mat4 projectionMatrix;

		uniform float skeletonData[400];//16*25

		attribute vec3 position;
		attribute vec2 inUV;
        attribute vec4 skinIndex;
        attribute vec4 skinWeight;

		attribute vec3 mcol0;
		attribute vec3 mcol1;
		attribute vec3 mcol2;
		attribute vec3 mcol3;

		attribute vec3 type;

        varying vec2 outUV;
        varying vec3 varyType;
        varying float varyMyTest0;

		void main(){
			vec3 vPosition = position;
			outUV = inUV;
			varyType=type;

			if(vPosition.y<0.15)varyMyTest0=0.0;//下身
			else if(vPosition.y<0.59) varyMyTest0=1.0;//上身
			else varyMyTest0=2.0;//头部

            mat4 matrixs[25];//25个骨骼的变换矩阵
			for(int i=0;i<25;i++){
			    matrixs[i]=mat4(//最后一行是：0 0 0 1
			        skeletonData[i*16+0] ,skeletonData[i*16+1] ,skeletonData[i*16+2] ,skeletonData[i*16+3] ,
			        skeletonData[i*16+4] ,skeletonData[i*16+5] ,skeletonData[i*16+6] ,skeletonData[i*16+7] ,
			        skeletonData[i*16+8] ,skeletonData[i*16+9] ,skeletonData[i*16+10],skeletonData[i*16+11],
			        skeletonData[i*16+12],skeletonData[i*16+13],skeletonData[i*16+14],skeletonData[i*16+15]
			        );
			}

            int mySkinIndex[4];//求skinIndex的近似整数，结果存入mySkinIndex
            for(int j=0;j<4;j++){
                float i0=0.0;
                for(int i=0;i<25;i++){
                   if((skinIndex[j]-i0)>-0.5&&(skinIndex[j]-i0)<0.5){
                            mySkinIndex[j]=i;
                            //if(i==2)varyMyTest0=1.0;
                   }
                   i0=i0+1.0;
                }
            }

            //计算动画的变换矩阵：matrix1=skinWeight[0]*matrixs[mySkinIndex[0]]+...
            mat4 matrix1=mat4(0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0);
            mat4 matrix_temp;
            for(int j=0;j<4;j++){
                for(int i=0;i<25;i++)if(i==mySkinIndex[j])matrix_temp=matrixs[i];
                matrix1=matrix1+skinWeight[j]*matrix_temp;
            }

            for(int i=0;i<4;i++)//对矩阵求转置
                for(int j=0;j<4;j++){
                    float temp=matrix1[i][j];
                    matrix1[i][j]=matrix1[j][i];
                    matrix1[j][i]=temp;
                }

			mat4 matrix2 = mat4(//确定位置//最后一列是 0 0 0 1
				vec4( mcol0, 0 ),
				vec4( mcol1, 0 ),
				vec4( mcol2, 0 ),
				vec4( mcol3, 1 )
			);

			gl_Position = projectionMatrix * modelViewMatrix*   matrix2 * matrix1 * vec4( position, 1.0 );
		}
</script>
<script id="fragmentShader" type="x-shader/x-fragment">
        precision highp float;
        uniform sampler2D text0;
        uniform sampler2D text1;
        uniform sampler2D text2;
        uniform sampler2D text3;
        uniform sampler2D text4;
        uniform sampler2D text5;
        uniform sampler2D text6;
        uniform sampler2D text7;
        uniform sampler2D text8;
        uniform sampler2D text9;
        uniform sampler2D text10;
        uniform sampler2D text11;
        uniform sampler2D text12;
        uniform sampler2D text13;
        uniform sampler2D text14;
        uniform sampler2D text15;

        varying float varyMyTest0;

        varying vec3 varyType;
		varying vec2 outUV;

		void main(){
			vec4 myTexture;
			float type;
            if(varyMyTest0>-0.5&&varyMyTest0<0.5)type=varyType[0];//下身
            else if(varyMyTest0>0.5&&varyMyTest0<1.5)type=varyType[1];
            else if(varyMyTest0>1.5&&varyMyTest0<2.5)type=varyType[2];

               if (type>-0.1&&type<0.1)myTexture =texture2D(text0, outUV);
			else if(type>0.9&&type<1.1)myTexture =texture2D(text1, outUV);
			else if(type>1.9&&type<2.1)myTexture =texture2D(text2, outUV);
			else if(type>2.9&&type<3.1)myTexture =texture2D(text3, outUV);
			else if(type>3.9&&type<4.1)myTexture =texture2D(text4, outUV);
			else if(type>4.9&&type<5.1)myTexture =texture2D(text5, outUV);
			else if(type>5.9&&type<6.1)myTexture =texture2D(text6, outUV);
			else if(type>6.9&&type<7.1)myTexture =texture2D(text7, outUV);
			else if(type>7.9&&type<8.1)myTexture =texture2D(text8, outUV);
			else if(type>8.9&&type<9.1)myTexture =texture2D(text9, outUV);
			else if(type>9.9&&type<10.1)myTexture =texture2D(text10, outUV);
			else if(type>10.9&&type<11.1)myTexture =texture2D(text11, outUV);
			else if(type>11.9&&type<12.1)myTexture =texture2D(text12, outUV);
			else if(type>12.9&&type<13.1)myTexture =texture2D(text13, outUV);
			else if(type>13.9&&type<14.1)myTexture =texture2D(text14, outUV);
			else if(type>14.9&&type<15.1)myTexture =texture2D(text15, outUV);

            float mytest0=varyType[1]*0.01;
            gl_FragColor = vec4 (myTexture.r,myTexture.g,myTexture.b,0);//varyType[0]
            //gl_FragColor =vec4 (0,varyType[1]*0.01,1,0);
		}
</script>
<script src="three.js"></script>
<script src="GLTFLoader.js"></script>
<script src="PMAnimLoader.js"></script>
<script src="OrbitControls.js"></script>
<script src="PlayerControl.js"></script>
<script src="InstancedGroup.js"></script>
<script>
    var attrUV = 1;
    var uniformTexture = 1;
    var mixer;

    let container;

    let camera, scene, renderer;
    let light;

    init();

    var loader= new THREE.GLTFLoader();
    loader.load('test2.glb', (glb) => {
        instancing(glb);
        render();
        function render() {
            renderer.render( scene, camera );
            requestAnimationFrame(render);
        }
    });

    function instancing(glb) {//开始进行实例化渲染


        var peoples=new InstancedGroup();
        peoples.init(glb.scene.children[0].children[1],glb.animations);
        scene.add(peoples.obj);

        camera.rotation.set( 1.4850434010742404, -0.01558289712906201,0.17931851636280588);
        camera.position.set(-0.3655338232857634,  -23.369285990164506,  2.0089112807939498);




    }

    function init() {
        container = document.getElementById('container');

        camera = new THREE.PerspectiveCamera(50, window.innerWidth / window.innerHeight, 0.01, 10000);
        camera.position.z = 2;

        scene = new THREE.Scene();

        renderer = new THREE.WebGLRenderer();
        renderer.setPixelRatio(window.devicePixelRatio);
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setClearColor(0xffffff);
        container.appendChild(renderer.domElement);

        if (renderer.capabilities.isWebGL2 === false && renderer.extensions.has('ANGLE_instanced_arrays') === false) {
            document.getElementById('notSupported').style.display = '';
            return;
        }
        light = new THREE.AmbientLight(0xffffff,1.0)
        scene.add(light);
        new OrbitControls(camera , renderer.domElement,THREE);
    }



</script>
</body>
</html>