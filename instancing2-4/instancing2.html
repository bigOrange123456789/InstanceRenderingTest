<!DOCTYPE html>
<html lang="en">
<head>
    <title>three.js webgl - instancing test (single triangle)</title>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
</head>
<body>
<canvas id="myCanvas" style="border:0px" width="0" height="0"></canvas>
<div id="container"></div>
<div id="info">
    <a href="https://threejs.org" target="_blank" rel="noopener"></a>
    <div id="notSupported" style="display:none">Sorry your graphics card + browser does not support hardware
        instancing
    </div>
</div>

<script id="vertexShader" type="x-shader/x-vertex">
		precision highp float;
		uniform mat4 modelViewMatrix;
		uniform mat4 projectionMatrix;

		attribute vec3 position;
		attribute vec2 inUV;
        varying vec2 outUV;
		attribute vec3 offset;
		attribute vec4 color;
		varying vec4 vColor;

		void main(){
			vec3 vPosition = position;
			vColor = color;
			outUV = inUV;
			gl_Position = projectionMatrix * modelViewMatrix * vec4( vPosition, 1.0 );
		}
</script>
<script id="fragmentShader" type="x-shader/x-fragment">
        precision lowp float;
        uniform sampler2D text;
		varying vec2 outUV;

		void main(){
			vec4 myTexture = texture2D(text, outUV);
            gl_FragColor = vec4 (myTexture.r,
                           myTexture.g,
                           myTexture.b,
                           1.0);
		}
</script>
<script src="three.js"></script>
<script src="GLTFLoader.js"></script>
<script src="OrbitControls.js"></script>
<script>
    var canvas = document.getElementById("myCanvas");//创建画布//createElement('canvas');
    var webgl = canvas.getContext("webgl")//获得webgl环境（上下文）


    var attrUV = 1;
    var uniformTexture = 1;


    let container;

    let camera, scene, renderer;
    let light;

    init();
    animate();
    instancing();

    function init() {
        container = document.getElementById('container');

        camera = new THREE.PerspectiveCamera(50, window.innerWidth / window.innerHeight, 1, 1000);
        camera.position.z = 2;

        scene = new THREE.Scene();


        renderer = new THREE.WebGLRenderer();
        renderer.setPixelRatio(window.devicePixelRatio);
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setClearColor(0xffffff);
        container.appendChild(renderer.domElement);

        if (renderer.capabilities.isWebGL2 === false && renderer.extensions.has('ANGLE_instanced_arrays') === false) {
            document.getElementById('notSupported').style.display = '';
            return;
        }

        light = new THREE.AmbientLight(0xffffff,1.0)
        scene.add(light);
    }

    function instancing() {//开始进行实例化渲染
        const instances = 1;

        const offsets = [];
        const colors = [];

        const geometry = new THREE.InstancedBufferGeometry();
        geometry.instanceCount = instances; // set so its initalized for dat.GUI, will be set in first draw otherwise
        //console.log(glb);

        const positions = [];
        positions.push( 0.25  , - 0.25, 0.25     );
        positions.push( - 0.25, 0.25  , 0.25     );
        positions.push( 0      , 0.25     , 0.25 );
        // positions.push(0, 0, 0);
        // positions.push(1, 0, 0);
        // positions.push(0, 1, 0);

        geometry.setAttribute('position', new THREE.Float32BufferAttribute(positions, 3));

        for (let i = 0; i < instances; i++) {
            // offsets.push(0, 1, -1);
            colors.push(1, 1, 1, 1);
        }

        // geometry.setAttribute('offset', new THREE.InstancedBufferAttribute(new Float32Array(offsets), 3));
        geometry.setAttribute('color', new THREE.InstancedBufferAttribute(new Float32Array(colors), 4));
        geometry.setAttribute('inUV', new THREE.InstancedBufferAttribute(new Float32Array([
            0, 0,
            0, 1,
            1, 0
        ]), 2));

        //var box = new THREE.Box3();
        let tex = THREE.ImageUtils.loadTexture('1.png');
        tex.wrapS = tex.wrapT = THREE.ClampToEdgeWrapping;
        console.log(tex);
        // texture.wrapS = texture.wrapT = THREE.RepeatWrapping;

        // material
        let material = new THREE.RawShaderMaterial({//原始着色器材质
            uniforms: {
                text: {type: 't', value: tex}//textureHandle
            },
            vertexShader: document.getElementById('vertexShader').textContent,
            fragmentShader: document.getElementById('fragmentShader').textContent,
            side: THREE.DoubleSide
        });

        const mesh = new THREE.Mesh(geometry, material);//重要
        scene.add(mesh);
        //完成进行实例化渲染
    }

    // function myInit2() {
    //     let TEX = THREE.ImageUtils.loadTexture('1.png',{},function () {
    //         renderer.render(scene, camera);
    //     });
    //
    //     let UNIFS = {
    //         img: { type: 't', value: TEX}
    //     };
    //     let VS = document.getElementById('vert').textContent;
    //     let FS = document.getElementById('frag').textContent;
    //
    //     let GEO = new THREE.PlaneBufferGeometry(1, 1, 1, 1);
    //     let MAT = new THREE.ShaderMaterial({
    //         uniforms: UNIFS,
    //         vertexShader: VS,
    //         fragmentShader: FS
    //     });
    //     let OBJ = new THREE.Mesh(GEO, MAT);
    //     scene.add(OBJ);
    // }

    function animate() {
        requestAnimationFrame(animate);
        renderer.render(scene, camera);
    }

</script>
</body>
</html>